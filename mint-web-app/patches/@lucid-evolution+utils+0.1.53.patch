diff --git a/node_modules/@lucid-evolution/utils/dist/index.cjs b/node_modules/@lucid-evolution/utils/dist/index.cjs
index 7ef82c3..a4c2530 100644
--- a/node_modules/@lucid-evolution/utils/dist/index.cjs
+++ b/node_modules/@lucid-evolution/utils/dist/index.cjs
@@ -30,11 +30,13 @@ var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: tru
 // src/index.ts
 var src_exports = {};
 __export(src_exports, {
+  CBOREncodingLevel: () => CBOREncodingLevel,
   PROTOCOL_PARAMETERS_DEFAULT: () => PROTOCOL_PARAMETERS_DEFAULT,
   addAssets: () => addAssets,
   addressFromHexOrBech32: () => addressFromHexOrBech32,
   applyDoubleCborEncoding: () => applyDoubleCborEncoding,
   applyParamsToScript: () => applyParamsToScript,
+  applySingleCborEncoding: () => applySingleCborEncoding,
   assetsToValue: () => assetsToValue,
   calculateMinLovelaceFromUTxO: () => calculateMinLovelaceFromUTxO,
   coreToOutRef: () => coreToOutRef,
@@ -192,13 +194,44 @@ function networkToId(network) {
 
 // src/cbor.ts
 var import_core_utils = require("@lucid-evolution/core-utils");
-var import_cborg = require("cborg");
+var import_cbor_x = require("cbor-x");
 var applyDoubleCborEncoding = (script) => {
   try {
-    (0, import_cborg.decode)((0, import_cborg.decode)((0, import_core_utils.fromHex)(script)));
+    (0, import_cbor_x.decode)((0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script)));
     return script;
   } catch (error) {
-    return (0, import_core_utils.toHex)((0, import_cborg.encode)((0, import_core_utils.fromHex)(script)));
+    try {
+      (0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script));
+      return (0, import_core_utils.toHex)(Uint8Array.from((0, import_cbor_x.encode)((0, import_core_utils.fromHex)(script).buffer)));
+    } catch (error2) {
+      return (0, import_core_utils.toHex)(Uint8Array.from((0, import_cbor_x.encode)((0, import_cbor_x.encode)((0, import_core_utils.fromHex)(script).buffer))));
+    }
+  }
+};
+var applySingleCborEncoding = (script) => {
+  try {
+    (0, import_cbor_x.decode)((0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script)));
+    return (0, import_core_utils.toHex)((0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script)));
+  } catch (error) {
+    try {
+      (0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script));
+      return script;
+    } catch (error2) {
+      return (0, import_core_utils.toHex)(Uint8Array.from((0, import_cbor_x.encode)((0, import_core_utils.fromHex)(script).buffer)));
+    }
+  }
+};
+var CBOREncodingLevel = (script) => {
+  try {
+    (0, import_cbor_x.decode)((0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script)));
+    return "double";
+  } catch (error) {
+    try {
+      (0, import_cbor_x.decode)((0, import_core_utils.fromHex)(script));
+      return "single";
+    } catch (error2) {
+      throw new Error("Script is not CBOR-encoded or invalid format.");
+    }
   }
 };
 function datumJsonToCbor(json) {
@@ -247,7 +280,7 @@ function datumJsonToCbor(json) {
 var import_plutus = require("@lucid-evolution/plutus");
 var import_uplc = require("@harmoniclabs/uplc");
 var import_core_utils2 = require("@lucid-evolution/core-utils");
-var import_cborg2 = require("cborg");
+var import_cbor_x2 = require("cbor-x");
 var import_plutus_data = require("@harmoniclabs/plutus-data");
 function validatorToAddress(network, validator, stakeCredential) {
   const validatorHash = validatorToScriptHash(validator);
@@ -354,7 +387,7 @@ function mintingPolicyToId(mintingPolicy) {
 }
 function applyParamsToScript(plutusScript, params, type) {
   const program = (0, import_uplc.parseUPLC)(
-    (0, import_cborg2.decode)((0, import_cborg2.decode)((0, import_core_utils2.fromHex)(applyDoubleCborEncoding(plutusScript)))),
+    (0, import_cbor_x2.decode)((0, import_cbor_x2.decode)((0, import_core_utils2.fromHex)(applyDoubleCborEncoding(plutusScript)))),
     "flat"
   );
   const parameters = type ? import_plutus.Data.castTo(params, type) : params;
@@ -363,11 +396,9 @@ function applyParamsToScript(plutusScript, params, type) {
     const appliedParameter = new import_uplc.Application(body, data);
     return appliedParameter;
   }, program.body);
-  return (0, import_core_utils2.toHex)(
-    (0, import_cborg2.encode)(
-      (0, import_cborg2.encode)(
-        (0, import_uplc.encodeUPLC)(new import_uplc.UPLCProgram(program.version, appliedProgram)).toBuffer().buffer
-      )
+  return applyDoubleCborEncoding(
+    (0, import_core_utils2.toHex)(
+      (0, import_uplc.encodeUPLC)(new import_uplc.UPLCProgram(program.version, appliedProgram)).toBuffer().buffer
     )
   );
 }
@@ -404,31 +435,20 @@ function validatorToRewardAddress(network, validator) {
 function getAddressDetails(address) {
   try {
     const parsedAddress = CML.BaseAddress.from_address(
-      CML.Address.from_bech32(address)
+      addressFromHexOrBech32(address)
     );
     const paymentCredential = parsedAddress.payment().kind() === 0 ? {
       type: "Key",
-      // hash: toHex(
-      //   parsedAddress.payment_cred().to_keyhash()!.to_bytes(),
-      // ),
       hash: parsedAddress.payment().as_pub_key().to_hex()
     } : {
       type: "Script",
-      // hash: toHex(
-      //   parsedAddress.payment_cred().to_scripthash()!.to_bytes(),
-      // ),
       hash: parsedAddress.payment().as_script().to_hex()
     };
-    const stakeCredential = parsedAddress.stake().kind() === 0 ? (
-      // parsedAddress.stake_cred().kind() === 0
-      {
-        type: "Key",
-        hash: parsedAddress.stake().as_pub_key().to_hex()
-        // hash: toHex(parsedAddress.stake_cred().to_keyhash()!.to_bytes()),
-      }
-    ) : {
+    const stakeCredential = parsedAddress.stake().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.stake().as_pub_key().to_hex()
+    } : {
       type: "Script",
-      // hash: toHex(parsedAddress.stake_cred().to_scripthash()!.to_bytes()),
       hash: parsedAddress.stake().as_script().to_hex()
     };
     return {
@@ -436,7 +456,6 @@ function getAddressDetails(address) {
       networkId: parsedAddress.to_address().network_id(),
       address: {
         bech32: parsedAddress.to_address().to_bech32(void 0),
-        // hex: toHex(parsedAddress.to_address().to_bytes()),
         hex: parsedAddress.to_address().to_hex()
       },
       paymentCredential,
@@ -446,18 +465,14 @@ function getAddressDetails(address) {
   }
   try {
     const parsedAddress = CML.EnterpriseAddress.from_address(
-      CML.Address.from_bech32(address)
+      addressFromHexOrBech32(address)
     );
     const paymentCredential = parsedAddress.payment().kind() === 0 ? {
       type: "Key",
-      // hash: toHex(parsedAddress.payment_cred().to_keyhash()!.to_bytes()),
       hash: parsedAddress.payment().as_pub_key().to_hex()
     } : {
       type: "Script",
-      hash: (
-        // parsedAddress.payment_cred().to_scripthash()!.to_bytes()
-        parsedAddress.payment().as_script().to_hex()
-      )
+      hash: parsedAddress.payment().as_script().to_hex()
     };
     return {
       type: "Enterprise",
@@ -472,15 +487,13 @@ function getAddressDetails(address) {
   }
   try {
     const parsedAddress = CML.PointerAddress.from_address(
-      CML.Address.from_bech32(address)
+      addressFromHexOrBech32(address)
     );
     const paymentCredential = parsedAddress?.payment().kind() === 0 ? {
       type: "Key",
-      // hash: toHex(parsedAddress.payment_cred().to_keyhash()!.to_bytes()),
       hash: parsedAddress.payment().as_pub_key().to_hex()
     } : {
       type: "Script",
-      // hash: toHex( parsedAddress.payment_cred().to_scripthash()!.to_bytes()),
       hash: parsedAddress.payment().as_script().to_hex()
     };
     return {
@@ -488,7 +501,6 @@ function getAddressDetails(address) {
       networkId: parsedAddress.to_address().network_id(),
       address: {
         bech32: parsedAddress.to_address().to_bech32(void 0),
-        // hex: toHex(parsedAddress.to_address().to_bytes()),
         hex: parsedAddress.to_address().to_hex()
       },
       paymentCredential
@@ -497,7 +509,7 @@ function getAddressDetails(address) {
   }
   try {
     const parsedAddress = CML.RewardAddress.from_address(
-      CML.Address.from_bech32(address)
+      addressFromHexOrBech32(address)
     );
     const stakeCredential = parsedAddress.payment().kind() === 0 ? {
       type: "Key",
@@ -511,7 +523,6 @@ function getAddressDetails(address) {
       networkId: parsedAddress.to_address().network_id(),
       address: {
         bech32: parsedAddress.to_address().to_bech32(void 0),
-        // hex: toHex(parsedAddress.to_address().to_bytes()),
         hex: parsedAddress.to_address().to_hex()
       },
       stakeCredential
@@ -535,7 +546,6 @@ function getAddressDetails(address) {
       networkId: parsedAddress.content().network_id(),
       address: {
         bech32: "",
-        // hex: toHex(parsedAddress.to_address().to_bytes()),
         hex: parsedAddress.to_address().to_hex()
       }
     };
@@ -1176,7 +1186,53 @@ var PROTOCOL_PARAMETERS_DEFAULT = {
       "247": 43623,
       "248": 251,
       "249": 0,
-      "250": 1
+      "250": 1,
+      "251": 100181,
+      "252": 726,
+      "253": 719,
+      "254": 0,
+      "255": 1,
+      "256": 100181,
+      "257": 726,
+      "258": 719,
+      "259": 0,
+      "260": 1,
+      "261": 100181,
+      "262": 726,
+      "263": 719,
+      "264": 0,
+      "265": 1,
+      "266": 107878,
+      "267": 680,
+      "268": 0,
+      "269": 1,
+      "270": 95336,
+      "271": 1,
+      "272": 281145,
+      "273": 18848,
+      "274": 0,
+      "275": 1,
+      "276": 180194,
+      "277": 159,
+      "278": 1,
+      "279": 1,
+      "280": 158519,
+      "281": 8942,
+      "282": 0,
+      "283": 1,
+      "284": 159378,
+      "285": 8813,
+      "286": 0,
+      "287": 1,
+      "288": 107490,
+      "289": 3298,
+      "290": 1,
+      "291": 106057,
+      "292": 655,
+      "293": 1,
+      "294": 1964219,
+      "295": 24520,
+      "296": 3
     }
   }
 };
@@ -1315,7 +1371,7 @@ function valueToAssets(value) {
 }
 function assetsToValue(assets) {
   const multiAsset = CML.MultiAsset.new();
-  const lovelace = assets["lovelace"] ? assets["lovelace"] : 0n;
+  const lovelace = assets["lovelace"] ? BigInt(assets["lovelace"]) : 0n;
   const units = Object.keys(assets);
   const policies = Array.from(
     new Set(
@@ -1499,8 +1555,19 @@ var sortUTxOs = (utxos, order = "LargestFirst") => {
       return [...utxos].sort(smallestFirst);
     case "Canonical":
       return [...utxos].sort(canonical);
+    case "Collateral":
+      return [...utxos].sort(collateralOrder);
   }
 };
+var collateralOrder = (a, b) => {
+  const lovelaceA = Number(a.assets["lovelace"]);
+  const lovelaceB = Number(b.assets["lovelace"]);
+  const assetsA = Object.keys(a.assets).length;
+  const assetsB = Object.keys(b.assets).length;
+  if (assetsA === 0 && assetsB > 0) return -1;
+  if (assetsB === 0 && assetsA > 0) return 1;
+  return lovelaceB - lovelaceA;
+};
 var largestFirst = (a, b) => {
   const lovelaceA = Number(a.assets["lovelace"]);
   const lovelaceB = Number(b.assets["lovelace"]);
@@ -1550,9 +1617,9 @@ var buildOutput = (utxo) => {
   return utxo.scriptRef ? buildDatum(utxo, builder).with_reference_script(toScriptRef(utxo.scriptRef)).next() : buildDatum(utxo, builder).next();
 };
 var buildDatum = (utxo, builder) => {
-  if (utxo.datumHash)
-    return builder.with_data(
-      CML.DatumOption.new_hash(CML.DatumHash.from_hex(utxo.datumHash))
+  if (utxo.datumHash && utxo.datum)
+    return builder.with_communication_data(
+      CML.PlutusData.from_cbor_hex(utxo.datum)
     );
   if (utxo.datum)
     return builder.with_data(
@@ -1607,11 +1674,13 @@ var fromCMLRedeemerTag = (tag) => {
 };
 // Annotate the CommonJS export names for ESM import in node:
 0 && (module.exports = {
+  CBOREncodingLevel,
   PROTOCOL_PARAMETERS_DEFAULT,
   addAssets,
   addressFromHexOrBech32,
   applyDoubleCborEncoding,
   applyParamsToScript,
+  applySingleCborEncoding,
   assetsToValue,
   calculateMinLovelaceFromUTxO,
   coreToOutRef,
diff --git a/node_modules/@lucid-evolution/utils/dist/index.d.cts b/node_modules/@lucid-evolution/utils/dist/index.d.cts
index 5a46a15..eb37cf3 100644
--- a/node_modules/@lucid-evolution/utils/dist/index.d.cts
+++ b/node_modules/@lucid-evolution/utils/dist/index.d.cts
@@ -66,6 +66,8 @@ declare function validatorToRewardAddress(network: Network, validator: Certifica
 declare function getAddressDetails(address: string): AddressDetails;
 
 declare const applyDoubleCborEncoding: (script: string) => string;
+declare const applySingleCborEncoding: (script: string) => string;
+declare const CBOREncodingLevel: (script: string) => "double" | "single";
 declare function datumJsonToCbor(json: DatumJson): Datum;
 
 declare function createCostModels(costModels: CostModels): CML.CostModels;
@@ -100,6 +102,15 @@ declare function mintingPolicyToId(mintingPolicy: MintingPolicy): PolicyId;
  */
 declare function applyParamsToScript<T extends unknown[] = Data[]>(plutusScript: string, params: Exact<[...T]>, type?: T): string;
 
+/**
+ * Converts unix time to slot based on the network. For "Custom" network
+ * it is advisable use `unixTimeToSlot` method from `LucidEvolution`
+ * instance to avoid uninitialized `SLOT_CONFIG_NETWORK` issue. More details
+ * on the issue can be found here https://github.com/Anastasia-Labs/lucid-evolution/pull/443
+ * @param network
+ * @param unixTime
+ * @returns Slot
+ */
 declare function unixTimeToSlot(network: Network, unixTime: UnixTime): Slot;
 declare function slotToUnixTime(network: Network, slot: Slot): UnixTime;
 
@@ -132,6 +143,10 @@ type SortOrder =
  * Smallest amount of "lovelace" with least number of unique assets first
  */
  | "SmallestFirst"
+/**
+ * Similar to Largest first, but we preference "clean" UTxOs first
+ */
+ | "Collateral"
 /**
  * Lexicographically sorted as per ledger rules
  */
@@ -193,4 +208,4 @@ declare const stringify: (data: any) => string;
 declare const toCMLRedeemerTag: (tag: string) => CML.RedeemerTag;
 declare const fromCMLRedeemerTag: (tag: CML.RedeemerTag) => RedeemerTag;
 
-export { type CMLNative, PROTOCOL_PARAMETERS_DEFAULT, type SortOrder, addAssets, addressFromHexOrBech32, applyDoubleCborEncoding, applyParamsToScript, assetsToValue, calculateMinLovelaceFromUTxO, coreToOutRef, coreToTxOutput, coreToUtxo, coresToOutRefs, coresToTxOutputs, coresToUtxos, createCostModels, credentialToAddress, credentialToRewardAddress, datumJsonToCbor, datumToHash, fromCMLRedeemerTag, fromLabel, fromScriptRef, fromUnit, generatePrivateKey, generateSeedPhrase, getAddressDetails, getInputIndices, getUniqueTokenName, isEqualUTxO, keyHashToCredential, mintingPolicyToId, networkToId, parseCMLNative, paymentCredentialOf, scriptFromCMLNative, scriptFromNative, scriptHashToCredential, selectUTxOs, slotToUnixTime, sortCanonical, sortUTxOs, stakeCredentialOf, stringify, toCMLNativeScript, toCMLRedeemerTag, toLabel, toPublicKey, toScriptRef, toUnit, unixTimeToSlot, utxoToCore, utxoToTransactionInput, utxoToTransactionOutput, utxosToCores, validatorToAddress, validatorToRewardAddress, validatorToScriptHash, valueToAssets };
+export { CBOREncodingLevel, type CMLNative, PROTOCOL_PARAMETERS_DEFAULT, type SortOrder, addAssets, addressFromHexOrBech32, applyDoubleCborEncoding, applyParamsToScript, applySingleCborEncoding, assetsToValue, calculateMinLovelaceFromUTxO, coreToOutRef, coreToTxOutput, coreToUtxo, coresToOutRefs, coresToTxOutputs, coresToUtxos, createCostModels, credentialToAddress, credentialToRewardAddress, datumJsonToCbor, datumToHash, fromCMLRedeemerTag, fromLabel, fromScriptRef, fromUnit, generatePrivateKey, generateSeedPhrase, getAddressDetails, getInputIndices, getUniqueTokenName, isEqualUTxO, keyHashToCredential, mintingPolicyToId, networkToId, parseCMLNative, paymentCredentialOf, scriptFromCMLNative, scriptFromNative, scriptHashToCredential, selectUTxOs, slotToUnixTime, sortCanonical, sortUTxOs, stakeCredentialOf, stringify, toCMLNativeScript, toCMLRedeemerTag, toLabel, toPublicKey, toScriptRef, toUnit, unixTimeToSlot, utxoToCore, utxoToTransactionInput, utxoToTransactionOutput, utxosToCores, validatorToAddress, validatorToRewardAddress, validatorToScriptHash, valueToAssets };
diff --git a/node_modules/@lucid-evolution/utils/dist/index.d.ts b/node_modules/@lucid-evolution/utils/dist/index.d.ts
index 5a46a15..eb37cf3 100644
--- a/node_modules/@lucid-evolution/utils/dist/index.d.ts
+++ b/node_modules/@lucid-evolution/utils/dist/index.d.ts
@@ -66,6 +66,8 @@ declare function validatorToRewardAddress(network: Network, validator: Certifica
 declare function getAddressDetails(address: string): AddressDetails;
 
 declare const applyDoubleCborEncoding: (script: string) => string;
+declare const applySingleCborEncoding: (script: string) => string;
+declare const CBOREncodingLevel: (script: string) => "double" | "single";
 declare function datumJsonToCbor(json: DatumJson): Datum;
 
 declare function createCostModels(costModels: CostModels): CML.CostModels;
@@ -100,6 +102,15 @@ declare function mintingPolicyToId(mintingPolicy: MintingPolicy): PolicyId;
  */
 declare function applyParamsToScript<T extends unknown[] = Data[]>(plutusScript: string, params: Exact<[...T]>, type?: T): string;
 
+/**
+ * Converts unix time to slot based on the network. For "Custom" network
+ * it is advisable use `unixTimeToSlot` method from `LucidEvolution`
+ * instance to avoid uninitialized `SLOT_CONFIG_NETWORK` issue. More details
+ * on the issue can be found here https://github.com/Anastasia-Labs/lucid-evolution/pull/443
+ * @param network
+ * @param unixTime
+ * @returns Slot
+ */
 declare function unixTimeToSlot(network: Network, unixTime: UnixTime): Slot;
 declare function slotToUnixTime(network: Network, slot: Slot): UnixTime;
 
@@ -132,6 +143,10 @@ type SortOrder =
  * Smallest amount of "lovelace" with least number of unique assets first
  */
  | "SmallestFirst"
+/**
+ * Similar to Largest first, but we preference "clean" UTxOs first
+ */
+ | "Collateral"
 /**
  * Lexicographically sorted as per ledger rules
  */
@@ -193,4 +208,4 @@ declare const stringify: (data: any) => string;
 declare const toCMLRedeemerTag: (tag: string) => CML.RedeemerTag;
 declare const fromCMLRedeemerTag: (tag: CML.RedeemerTag) => RedeemerTag;
 
-export { type CMLNative, PROTOCOL_PARAMETERS_DEFAULT, type SortOrder, addAssets, addressFromHexOrBech32, applyDoubleCborEncoding, applyParamsToScript, assetsToValue, calculateMinLovelaceFromUTxO, coreToOutRef, coreToTxOutput, coreToUtxo, coresToOutRefs, coresToTxOutputs, coresToUtxos, createCostModels, credentialToAddress, credentialToRewardAddress, datumJsonToCbor, datumToHash, fromCMLRedeemerTag, fromLabel, fromScriptRef, fromUnit, generatePrivateKey, generateSeedPhrase, getAddressDetails, getInputIndices, getUniqueTokenName, isEqualUTxO, keyHashToCredential, mintingPolicyToId, networkToId, parseCMLNative, paymentCredentialOf, scriptFromCMLNative, scriptFromNative, scriptHashToCredential, selectUTxOs, slotToUnixTime, sortCanonical, sortUTxOs, stakeCredentialOf, stringify, toCMLNativeScript, toCMLRedeemerTag, toLabel, toPublicKey, toScriptRef, toUnit, unixTimeToSlot, utxoToCore, utxoToTransactionInput, utxoToTransactionOutput, utxosToCores, validatorToAddress, validatorToRewardAddress, validatorToScriptHash, valueToAssets };
+export { CBOREncodingLevel, type CMLNative, PROTOCOL_PARAMETERS_DEFAULT, type SortOrder, addAssets, addressFromHexOrBech32, applyDoubleCborEncoding, applyParamsToScript, applySingleCborEncoding, assetsToValue, calculateMinLovelaceFromUTxO, coreToOutRef, coreToTxOutput, coreToUtxo, coresToOutRefs, coresToTxOutputs, coresToUtxos, createCostModels, credentialToAddress, credentialToRewardAddress, datumJsonToCbor, datumToHash, fromCMLRedeemerTag, fromLabel, fromScriptRef, fromUnit, generatePrivateKey, generateSeedPhrase, getAddressDetails, getInputIndices, getUniqueTokenName, isEqualUTxO, keyHashToCredential, mintingPolicyToId, networkToId, parseCMLNative, paymentCredentialOf, scriptFromCMLNative, scriptFromNative, scriptHashToCredential, selectUTxOs, slotToUnixTime, sortCanonical, sortUTxOs, stakeCredentialOf, stringify, toCMLNativeScript, toCMLRedeemerTag, toLabel, toPublicKey, toScriptRef, toUnit, unixTimeToSlot, utxoToCore, utxoToTransactionInput, utxoToTransactionOutput, utxosToCores, validatorToAddress, validatorToRewardAddress, validatorToScriptHash, valueToAssets };
diff --git a/node_modules/@lucid-evolution/utils/dist/index.js b/node_modules/@lucid-evolution/utils/dist/index.js
index 1ee9aa9..c596343 100644
--- a/node_modules/@lucid-evolution/utils/dist/index.js
+++ b/node_modules/@lucid-evolution/utils/dist/index.js
@@ -100,13 +100,44 @@ function networkToId(network) {
 
 // src/cbor.ts
 import { fromHex, toHex } from "@lucid-evolution/core-utils";
-import { decode, encode } from "cborg";
+import { decode, encode } from "cbor-x";
 var applyDoubleCborEncoding = (script) => {
   try {
     decode(decode(fromHex(script)));
     return script;
   } catch (error) {
-    return toHex(encode(fromHex(script)));
+    try {
+      decode(fromHex(script));
+      return toHex(Uint8Array.from(encode(fromHex(script).buffer)));
+    } catch (error2) {
+      return toHex(Uint8Array.from(encode(encode(fromHex(script).buffer))));
+    }
+  }
+};
+var applySingleCborEncoding = (script) => {
+  try {
+    decode(decode(fromHex(script)));
+    return toHex(decode(fromHex(script)));
+  } catch (error) {
+    try {
+      decode(fromHex(script));
+      return script;
+    } catch (error2) {
+      return toHex(Uint8Array.from(encode(fromHex(script).buffer)));
+    }
+  }
+};
+var CBOREncodingLevel = (script) => {
+  try {
+    decode(decode(fromHex(script)));
+    return "double";
+  } catch (error) {
+    try {
+      decode(fromHex(script));
+      return "single";
+    } catch (error2) {
+      throw new Error("Script is not CBOR-encoded or invalid format.");
+    }
   }
 };
 function datumJsonToCbor(json) {
@@ -161,7 +192,7 @@ import {
   UPLCProgram
 } from "@harmoniclabs/uplc";
 import { fromHex as fromHex2, toHex as toHex2 } from "@lucid-evolution/core-utils";
-import { decode as decode2, encode as encode2 } from "cborg";
+import { decode as decode2 } from "cbor-x";
 import { dataFromCbor } from "@harmoniclabs/plutus-data";
 function validatorToAddress(network, validator, stakeCredential) {
   const validatorHash = validatorToScriptHash(validator);
@@ -277,11 +308,9 @@ function applyParamsToScript(plutusScript, params, type) {
     const appliedParameter = new Application(body, data);
     return appliedParameter;
   }, program.body);
-  return toHex2(
-    encode2(
-      encode2(
-        encodeUPLC(new UPLCProgram(program.version, appliedProgram)).toBuffer().buffer
-      )
+  return applyDoubleCborEncoding(
+    toHex2(
+      encodeUPLC(new UPLCProgram(program.version, appliedProgram)).toBuffer().buffer
     )
   );
 }
@@ -318,31 +347,20 @@ function validatorToRewardAddress(network, validator) {
 function getAddressDetails(address) {
   try {
     const parsedAddress = CML.BaseAddress.from_address(
-      CML.Address.from_bech32(address)
+      addressFromHexOrBech32(address)
     );
     const paymentCredential = parsedAddress.payment().kind() === 0 ? {
       type: "Key",
-      // hash: toHex(
-      //   parsedAddress.payment_cred().to_keyhash()!.to_bytes(),
-      // ),
       hash: parsedAddress.payment().as_pub_key().to_hex()
     } : {
       type: "Script",
-      // hash: toHex(
-      //   parsedAddress.payment_cred().to_scripthash()!.to_bytes(),
-      // ),
       hash: parsedAddress.payment().as_script().to_hex()
     };
-    const stakeCredential = parsedAddress.stake().kind() === 0 ? (
-      // parsedAddress.stake_cred().kind() === 0
-      {
-        type: "Key",
-        hash: parsedAddress.stake().as_pub_key().to_hex()
-        // hash: toHex(parsedAddress.stake_cred().to_keyhash()!.to_bytes()),
-      }
-    ) : {
+    const stakeCredential = parsedAddress.stake().kind() === 0 ? {
+      type: "Key",
+      hash: parsedAddress.stake().as_pub_key().to_hex()
+    } : {
       type: "Script",
-      // hash: toHex(parsedAddress.stake_cred().to_scripthash()!.to_bytes()),
       hash: parsedAddress.stake().as_script().to_hex()
     };
     return {
@@ -350,7 +368,6 @@ function getAddressDetails(address) {
       networkId: parsedAddress.to_address().network_id(),
       address: {
         bech32: parsedAddress.to_address().to_bech32(void 0),
-        // hex: toHex(parsedAddress.to_address().to_bytes()),
         hex: parsedAddress.to_address().to_hex()
       },
       paymentCredential,
@@ -360,18 +377,14 @@ function getAddressDetails(address) {
   }
   try {
     const parsedAddress = CML.EnterpriseAddress.from_address(
-      CML.Address.from_bech32(address)
+      addressFromHexOrBech32(address)
     );
     const paymentCredential = parsedAddress.payment().kind() === 0 ? {
       type: "Key",
-      // hash: toHex(parsedAddress.payment_cred().to_keyhash()!.to_bytes()),
       hash: parsedAddress.payment().as_pub_key().to_hex()
     } : {
       type: "Script",
-      hash: (
-        // parsedAddress.payment_cred().to_scripthash()!.to_bytes()
-        parsedAddress.payment().as_script().to_hex()
-      )
+      hash: parsedAddress.payment().as_script().to_hex()
     };
     return {
       type: "Enterprise",
@@ -386,15 +399,13 @@ function getAddressDetails(address) {
   }
   try {
     const parsedAddress = CML.PointerAddress.from_address(
-      CML.Address.from_bech32(address)
+      addressFromHexOrBech32(address)
     );
     const paymentCredential = parsedAddress?.payment().kind() === 0 ? {
       type: "Key",
-      // hash: toHex(parsedAddress.payment_cred().to_keyhash()!.to_bytes()),
       hash: parsedAddress.payment().as_pub_key().to_hex()
     } : {
       type: "Script",
-      // hash: toHex( parsedAddress.payment_cred().to_scripthash()!.to_bytes()),
       hash: parsedAddress.payment().as_script().to_hex()
     };
     return {
@@ -402,7 +413,6 @@ function getAddressDetails(address) {
       networkId: parsedAddress.to_address().network_id(),
       address: {
         bech32: parsedAddress.to_address().to_bech32(void 0),
-        // hex: toHex(parsedAddress.to_address().to_bytes()),
         hex: parsedAddress.to_address().to_hex()
       },
       paymentCredential
@@ -411,7 +421,7 @@ function getAddressDetails(address) {
   }
   try {
     const parsedAddress = CML.RewardAddress.from_address(
-      CML.Address.from_bech32(address)
+      addressFromHexOrBech32(address)
     );
     const stakeCredential = parsedAddress.payment().kind() === 0 ? {
       type: "Key",
@@ -425,7 +435,6 @@ function getAddressDetails(address) {
       networkId: parsedAddress.to_address().network_id(),
       address: {
         bech32: parsedAddress.to_address().to_bech32(void 0),
-        // hex: toHex(parsedAddress.to_address().to_bytes()),
         hex: parsedAddress.to_address().to_hex()
       },
       stakeCredential
@@ -449,7 +458,6 @@ function getAddressDetails(address) {
       networkId: parsedAddress.content().network_id(),
       address: {
         bech32: "",
-        // hex: toHex(parsedAddress.to_address().to_bytes()),
         hex: parsedAddress.to_address().to_hex()
       }
     };
@@ -1090,7 +1098,53 @@ var PROTOCOL_PARAMETERS_DEFAULT = {
       "247": 43623,
       "248": 251,
       "249": 0,
-      "250": 1
+      "250": 1,
+      "251": 100181,
+      "252": 726,
+      "253": 719,
+      "254": 0,
+      "255": 1,
+      "256": 100181,
+      "257": 726,
+      "258": 719,
+      "259": 0,
+      "260": 1,
+      "261": 100181,
+      "262": 726,
+      "263": 719,
+      "264": 0,
+      "265": 1,
+      "266": 107878,
+      "267": 680,
+      "268": 0,
+      "269": 1,
+      "270": 95336,
+      "271": 1,
+      "272": 281145,
+      "273": 18848,
+      "274": 0,
+      "275": 1,
+      "276": 180194,
+      "277": 159,
+      "278": 1,
+      "279": 1,
+      "280": 158519,
+      "281": 8942,
+      "282": 0,
+      "283": 1,
+      "284": 159378,
+      "285": 8813,
+      "286": 0,
+      "287": 1,
+      "288": 107490,
+      "289": 3298,
+      "290": 1,
+      "291": 106057,
+      "292": 655,
+      "293": 1,
+      "294": 1964219,
+      "295": 24520,
+      "296": 3
     }
   }
 };
@@ -1233,7 +1287,7 @@ function valueToAssets(value) {
 }
 function assetsToValue(assets) {
   const multiAsset = CML.MultiAsset.new();
-  const lovelace = assets["lovelace"] ? assets["lovelace"] : 0n;
+  const lovelace = assets["lovelace"] ? BigInt(assets["lovelace"]) : 0n;
   const units = Object.keys(assets);
   const policies = Array.from(
     new Set(
@@ -1417,8 +1471,19 @@ var sortUTxOs = (utxos, order = "LargestFirst") => {
       return [...utxos].sort(smallestFirst);
     case "Canonical":
       return [...utxos].sort(canonical);
+    case "Collateral":
+      return [...utxos].sort(collateralOrder);
   }
 };
+var collateralOrder = (a, b) => {
+  const lovelaceA = Number(a.assets["lovelace"]);
+  const lovelaceB = Number(b.assets["lovelace"]);
+  const assetsA = Object.keys(a.assets).length;
+  const assetsB = Object.keys(b.assets).length;
+  if (assetsA === 0 && assetsB > 0) return -1;
+  if (assetsB === 0 && assetsA > 0) return 1;
+  return lovelaceB - lovelaceA;
+};
 var largestFirst = (a, b) => {
   const lovelaceA = Number(a.assets["lovelace"]);
   const lovelaceB = Number(b.assets["lovelace"]);
@@ -1468,9 +1533,9 @@ var buildOutput = (utxo) => {
   return utxo.scriptRef ? buildDatum(utxo, builder).with_reference_script(toScriptRef(utxo.scriptRef)).next() : buildDatum(utxo, builder).next();
 };
 var buildDatum = (utxo, builder) => {
-  if (utxo.datumHash)
-    return builder.with_data(
-      CML.DatumOption.new_hash(CML.DatumHash.from_hex(utxo.datumHash))
+  if (utxo.datumHash && utxo.datum)
+    return builder.with_communication_data(
+      CML.PlutusData.from_cbor_hex(utxo.datum)
     );
   if (utxo.datum)
     return builder.with_data(
@@ -1524,11 +1589,13 @@ var fromCMLRedeemerTag = (tag) => {
   }
 };
 export {
+  CBOREncodingLevel,
   PROTOCOL_PARAMETERS_DEFAULT,
   addAssets,
   addressFromHexOrBech32,
   applyDoubleCborEncoding,
   applyParamsToScript,
+  applySingleCborEncoding,
   assetsToValue,
   calculateMinLovelaceFromUTxO,
   coreToOutRef,
